Class Design

Working with Inheritance
■ Describe inheritance and its benefits
■ Develop code that demonstrates the use of polymorphism; including overriding and object type versus reference type
■ Determine when casting is necessary
■ Use super and this to access objects and constructors
■ Use abstract classes and interfaces
====================================================================================================

Introducing Class Inheritance

Inheritance is the process by which the new child subclass automatically includes any public or protected primitives, objects, or methods defined in the parent class.

Inheritance is transitive :D

Java supports single inheritance, by which a class may inherit from only one direct par- ent class.
Java also supports multiple levels of inheritance
To truly understand single inheritance, it may helpful to contrast it with multiple inheri- tance, by which a class may have multiple direct parents. 

!!!! Java does allow one exception to the single inheritance rule: classes may implement multiple interfaces

It is possible in Java to prevent a class from being extended by marking the class with the final modifier. 
====================================================================================================
Extending a Class

In Java, you can extend a class by adding the parent class name in the definition using the extends keyword

public abstract class ElephantSeal extends Seal {
                // Methods and Variables defined here
}

public or default access modifier
abstract : abstract or final keyword (optional)
Class - required
Class name
Extends parent class- optional

!!!Java allows only one public class per file,
====================================================================================================
Applying Class Access Modifiers

you can apply access modifiers (public, private, protected, default) to both class methods and variables

For the OCA exam, you should only be familiar with public and default package-level class access modifiers, because these are the only ones that can be applied to top-level classes within a Java file. The protected and private modifiers can only be applied to inner classes, which are classes that are defined within other classes, but this is well out of scope for the OCA exam.


The public access modifier applied to a class indicates that it can be referenced and used in any class. 
The default package private modifier, which is the lack of any access modifier, indicates the class can be accessed only by a subclass or class within the same package.

!!!!As you know, a Java file can have many classes but at most one public class. it may have no public class at all.

For simplicity, any time you see multiple public classes or interfaces defined in the same code block in this chapter, assume each class is defined in its own Java file.
====================================================================================================
Creating Java Objects

In Java, all classes inherit from a single class, java.lang.Object.
Furthermore, java.lang.Object is the only class that doesn’t have any parent classes.

Example for what we don't see , but is done:

public class Zoo { }
public class Zoo extends java.lang.Object { }

!!!!!All classes extend the java.lang.Object class

====================================================================================================

Defining Constructors

every class has at least one constructor.
In the case that no constructor is declared, the compiler will automatically insert a default no-argument constructor. In the case of extending a class, though, things are a bit more interesting.

In Java, the first statement of every constructor is either a call to another constructor within the class, using this(), or a call to a constructor in the direct parent class, using
super().

If a parent constructor takes arguments, the super constructor would also take arguments. For simplicity in this section, we refer to the super() command as any par- ent constructor, even those that take an argument.

the super() command may only be used as the first statement of the constructor

====================================================================================================
Understanding Compiler Enhancements


the following three class and constructor definitions are equivalent, because the compiler will automatically convert them all to the last example:
public class Donkey { }
public class Donkey { public Donkey() {}}
public class Donkey { public Donkey() {super();} }


Example 1 : does not compile:
public class Mammal { public Mammal(int age) { }} -- we do not have a no-argument constructor
public class Elephant extends Mammal { }

no constructor is defined within the Elephant class, so the compiler tries to insert a default no-argument constructor with a super() call, as it did in the Donkey example. The compiler stops, though, when it realizes there is no parent constructor that takes no arguments.


Example 2: also does not compile:
public class Mammal { public Mammal(int age) { }}
public class Elephant extends Mammal { public Elephant() { }}

because the compiler tries to insert the no- argument super() as the first statement of the constructor in the Elephant class, and there is no such constructor in the parent class


This is how it is fixed:


public class Mammal { public Mammal(int age) { }}
public class Elephant extends Mammal { public Elephant() {super(10); }}

Use a constructor super as in the parent class

!!!Note that the class Elephant now has a no-argument constructor even though its parent class Mammal doesn’t. Subclasses may define no-argument constructors even if their parent classes do not, provided the constructor of the child maps to a parent constructor via an explicit call of the super() command.

====================================================================================================

Reviewing Constructor Rules

Constructor Definition Rules:
1. The first statement of every constructor is a call to another constructor within the class using this(), or a call to a constructor in the direct parent class using super().
2. The super() call may not be used after the first statement of the constructor.
3. If no super() call is declared in a constructor, Java will insert a no-argument super() as the first statement of the constructor.
4. If the parent doesn’t have a no-argument constructor and the child doesn’t define any constructors, the compiler will throw an error and try to insert a default no-argument constructor into the child class.
5. If the parent doesn’t have a no-argument constructor, the compiler requires an explicit call to a parent constructor in each child constructor.

====================================================================================================

Calling Constructors
In Java, the parent constructor is always executed before the child constructor.
====================================================================================================

Calling Inherited Class Members


Java classes may use any public or protected member of the parent class, including meth- ods, primitives, or object references. If the parent class and child class are part of the same package, the child class may also use any default members defined in the parent class. Finally, a child class may never access a private member of the parent class, at least not through any direct reference. As you saw in the first example in this chapter, a private member age may be accessed indirectly via a public or protected method.

this() and this are unrelated in Java. Likewise, super() and super are quite different but may be used in the same methods on the exam. The first, super(), is a statement that explicitly calls a parent constructor and may only be used in the first line of a constructor of a child class. The second, super, is a keyword used to ref- erence a member defined in a parent class and may be used throughout the child class.

 When you see super() or super on the exam, be sure to check that they are being used correctly.
example: public Rabbit(int age) { super(); super.setAge(10);}

====================================================================================================
Inheriting Methods

Overriding a Method

The compiler performs the following checks when you override a nonprivate method:


1. The method in the child class must have the same signature as the method in the parent class.
2. The method in the child class must be at least as accessible or more accessible than the method in the parent class.
3. The method in the child class may not throw a checked exception that is new or broader than the class of any exception thrown in the parent class method.
4. If the method returns a value, it must be the same or a subclass of the method in the parent class, known as covariant return types.


Any time you see a method on the exam with the same name as a method in the parent class, determine whether the method is being overloaded or overridden first; doing so will help you with questions about whether the code will compile.

If parent class has protected - child class cannot have private- because is more restrictive: 2nd rule "the child method must be at least as accessible as the parent"
====================================================================================================

Redeclaring private Methods

In Java, it is not possible to override a private method in a parent class since the parent method is not accessible from the child class

====================================================================================================


Hiding Static Methods
 The rules: - same as for overriding + one more - to have static
The method in the child class must have the same signature as the method in the parent class.
2. The method in the child class must be at least as accessible or more accessible than the method in the parent class.
3. The method in the child class may not throw a checked exception that is new or broader than the class of any exception thrown in the parent class method.
4. If the method returns a value, it must be the same or a subclass of the method in the parent class, known as covariant return types.
5. The method defined in the child class must be marked as static if it is marked as static in the parent class (method hiding). Likewise, the method must not be marked as static in the child class if it is not marked as static in the parent class (method overriding).


Seems that is better not to use this static hiding
====================================================================================================

Overriding vs. Hiding Methods

In our description of hiding of static methods, we indicated there was a distinction between overriding and hiding methods. Unlike overriding a method, in which a child method replaces the parent method in calls defined in both the parent and child, hidden methods only replace parent methods in the calls defined in the child class.
At runtime the child version of an overridden method is always executed for an instance regardless of whether the method call is defined in a parent or child class method. In this manner, the parent method is never used unless an explicit call to the parent method is referenced, using the syntax ParentClassName.method(). Alternatively, at runtime the parent version of a hidden method is always executed if the call to the method is defined in the parent class.

====================================================================================================

Creating final methods
!!!!final methods cannot be overridden.


public class Bird {
public final boolean hasFeathers() {
return true; }
}
public class Penguin extends Bird {
public final boolean hasFeathers() { // DOES NOT COMPILE - because in parent class the method is final
return false; }
}

In short, the final modifier is only used on methods when the author of the parent method wants to guarantee very precise behavior.


====================================================================================================
Inheriting Variables
the rules for variables with the same name in the parent and child classes are a lot simpler, because Java doesn’t allow variables to be overridden but instead hidden.


Hiding Variables

you can reference the parent value of the variable with an explicit use of the super keyword.


Don't hide variables in practice !!! :))))

public class Animal {
public int length = 2;
}
public class Jellyfish extends Animal {
public int length = 5;
public static void main(String[] args) {
Jellyfish jellyfish = new Jellyfish();
Animal animal = new Jellyfish();
System.out.println(jellyfish.length);
System.out.println(animal.length);
} }

output:
5
2



====================================================================================================


Creating Abstract Classes


Default Method Implementations in Abstract Classes
Although you can’t provide a default implementation to an abstract method in an abstract class, you can still define a method with a body—you just can’t mark it as abstract. As long as you do not mark it as final, the subclass still has the option to override it, as explained in the previous section.

By definition, an abstract class is one that must be extended by another class to be instantiated, whereas a final class can’t be extended by another class. By marking an abstract class as final, you’re saying the class can never be instantiated, so the compiler refuses to process the code.


So abstract never goes with final!!!!

Also abstract doesn't go with private!!!!
====================================================================================================


Creating a Concrete Class

public abstract class Eel {
public static void main(String[] args) {
	final Eel eel = new Eel(); // DOES NOT COMPILE
}
}

An abstract class becomes useful when it is extended by a concrete subclass.

When you see a concrete class extending an abstract class on the exam, check that it implements all of the required abstract methods.

The key point is that the first class to extend the nonabstract class must implement all inherited abstract methods.
====================================================================================================

Extending an Abstract Class


There is one exception to the rule for abstract methods and concrete classes: a concrete subclass is not required to provide an implementation for an abstract method if an interme- diate abstract class provides the implementation

the subclasses do not consider it an inherited abstract method because it is no longer abstract by the time it reaches the subclasses.



Abstract Class Definition Rules:
1. Abstract classes cannot be instantiated directly.
2. Abstract classes may be defined with any number, including zero, of abstract and non-
abstract methods.
3. Abstract classes may not be marked as private or final.
4. An abstract class that extends another abstract class inherits all of its abstract methods as its own abstract methods.
5. The first concrete class that extends an abstract class must provide an implementation for all of the inherited abstract methods.

Abstract Method Definition Rules:
1. Abstract methods may only be defined in abstract classes.
2. Abstract methods may not be declared private or final.
3. Abstract methods must not provide a method body/implementation in the abstract class for which is it declared.
4. Implementing an abstract method in a subclass follows the same rules for overriding a method. For example, the name and signature must be the same, and the visibility of the method in the subclass must be at least as accessible as the method in the parent class.



====================================================================================================
Implementing Interfaces
Although Java doesn’t allow multiple inheritance, it does allow classes to implement any number of interfaces. An interface is an abstract data type that defines a list of abstract public methods that any class implementing the interface must provide. An interface can also include a list of constant variables and default methods.

 In Java, an interface is defined with the interface keyword, analogous to the class keyword used when defining a class. A class invokes the interface by using the implements keyword in its class definition.

public abstract interface CanBurrow {

	public static final int MINIMUM_DEPTH = 2;

	public abstract int getMaximumDepth();
}


public class FieldMouse implements CanBurrow {
                public int getMaximumDepth() {
                     return 10;
} }
A class may implement multiple interfaces, each separated by a comma, such as in the following example:
public class Elephant implements WalksOnFourLegs, HasTrunk, Herbivore { }

====================================================================================================

Defining an Interface

1. Interfaces cannot be instantiated directly.
2. An interface is not required to have any methods.
3. An interface may not be marked as final.
4. All top-level interfaces are assumed to have public or default access, and they must include the abstract modifier in their definition. Therefore, marking an interface as private, protected, or final will trigger a compiler error, since this is incompatible with these assumptions.
5. All nondefault methods in an interface are assumed to have the modifiers abstract and public in their definition. Therefore, marking a method as private, protected, or final will trigger compiler errors as these are incompatible with the abstract and public keywords.

---without the public abstract
public interface CanFly {
void fly(int speed);
abstract void takeoff();
public abstract double dive();
}

---what compiler convert
public abstract interface CanFly {
public abstract void fly(int speed);
public abstract void takeoff();
public abstract double dive();
}


Adding the assumed keywords to an interface is a matter of personal preference, although it is considered good coding practice to do so. Code with the assumed keywords written out tends to be easier and clearer to read, and leads to fewer potential conflicts, as you saw in the previous examples.

====================================================================================================

Inheriting an Interface


1. An interface that extends another interface, as well as an abstract class that implements an interface, inherits all of the abstract methods as its own abstract methods.
2. The first concrete class that implements an interface, or extends an abstract class that implements an interface, must provide an implementation for all of the inherited abstract methods.


====================================================================================================

Classes, Interfaces, and Keywords

!!!Make sure the only connection between a class and an interface is with the class implements interface syntax.


====================================================================================================

Abstract Methods and Multiple Inheritance
